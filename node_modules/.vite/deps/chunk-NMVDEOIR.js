// node_modules/@zumer/snapdom/dist/modules/chunks/chunk-GZX3IERM.js
var s = { image: /* @__PURE__ */ new Map(), background: /* @__PURE__ */ new Map(), resource: /* @__PURE__ */ new Map(), defaultStyle: /* @__PURE__ */ new Map(), baseStyle: /* @__PURE__ */ new Map(), computedStyle: /* @__PURE__ */ new WeakMap(), font: /* @__PURE__ */ new Set(), session: { styleMap: /* @__PURE__ */ new Map(), styleCache: /* @__PURE__ */ new WeakMap(), nodeMap: /* @__PURE__ */ new Map() } };
function et(t = "soft") {
  switch (s.session.__counterEpoch = (s.session.__counterEpoch || 0) + 1, t) {
    case "auto": {
      s.session.styleMap = /* @__PURE__ */ new Map(), s.session.nodeMap = /* @__PURE__ */ new Map();
      return;
    }
    case "soft": {
      s.session.styleMap = /* @__PURE__ */ new Map(), s.session.nodeMap = /* @__PURE__ */ new Map(), s.session.styleCache = /* @__PURE__ */ new WeakMap();
      return;
    }
    case "full":
      return;
    case "disabled": {
      s.session.styleMap = /* @__PURE__ */ new Map(), s.session.nodeMap = /* @__PURE__ */ new Map(), s.session.styleCache = /* @__PURE__ */ new WeakMap(), s.computedStyle = /* @__PURE__ */ new WeakMap(), s.baseStyle = /* @__PURE__ */ new Map(), s.defaultStyle = /* @__PURE__ */ new Map(), s.image = /* @__PURE__ */ new Map(), s.background = /* @__PURE__ */ new Map(), s.resource = /* @__PURE__ */ new Map(), s.font = /* @__PURE__ */ new Set();
      return;
    }
    default: {
      s.session.styleMap = /* @__PURE__ */ new Map(), s.session.nodeMap = /* @__PURE__ */ new Map(), s.session.styleCache = /* @__PURE__ */ new WeakMap();
      return;
    }
  }
}
function A(t) {
  let e = t.match(/url\((['"]?)(.*?)(\1)\)/);
  if (!e) return null;
  let n = e[2].trim();
  return n.startsWith("#") ? null : n;
}
function B(t) {
  if (!t || t === "none") return "";
  let e = t.replace(/translate[XY]?\([^)]*\)/g, "");
  return e = e.replace(/matrix\(([^)]+)\)/g, (n, o) => {
    let r = o.split(",").map((a) => a.trim());
    return r.length !== 6 ? `matrix(${o})` : (r[4] = "0", r[5] = "0", `matrix(${r.join(", ")})`);
  }), e = e.replace(/matrix3d\(([^)]+)\)/g, (n, o) => {
    let r = o.split(",").map((a) => a.trim());
    return r.length !== 16 ? `matrix3d(${o})` : (r[12] = "0", r[13] = "0", `matrix3d(${r.join(", ")})`);
  }), e.trim().replace(/\s{2,}/g, " ");
}
function g(t) {
  if (/%[0-9A-Fa-f]{2}/.test(t)) return t;
  try {
    return encodeURI(t);
  } catch {
    return t;
  }
}
function D(t = "[snapDOM]", { ttlMs: e = 5 * 6e4, maxEntries: n = 12 } = {}) {
  let o = /* @__PURE__ */ new Map(), r = 0;
  function a(l, f, d) {
    if (r >= n) return;
    let m = Date.now();
    (o.get(f) || 0) > m || (o.set(f, m + e), r++, l === "warn" && console && console.warn ? console.warn(`${t} ${d}`) : console && console.error && console.error(`${t} ${d}`));
  }
  return { warnOnce(l, f) {
    a("warn", l, f);
  }, errorOnce(l, f) {
    a("error", l, f);
  }, reset() {
    o.clear(), r = 0;
  } };
}
var R = D("[snapDOM]", { ttlMs: 3 * 6e4, maxEntries: 10 });
var k = /* @__PURE__ */ new Map();
var b = /* @__PURE__ */ new Map();
function N(t) {
  return /^data:|^blob:|^about:blank$/i.test(t);
}
function F(t, e) {
  try {
    let n = typeof location < "u" && location.href ? location.href : "http://localhost/", o = e.includes("{url}") ? e.split("{url}")[0] : e, r = new URL(o || ".", n), a = new URL(t, n);
    if (a.origin === r.origin) return true;
    let l = a.searchParams;
    if (l && (l.has("url") || l.has("target"))) return true;
  } catch {
  }
  return false;
}
function P(t, e) {
  if (!e || N(t) || F(t, e)) return false;
  try {
    let n = typeof location < "u" && location.href ? location.href : "http://localhost/", o = new URL(t, n);
    return typeof location < "u" ? o.origin !== location.origin : true;
  } catch {
    return !!e;
  }
}
function j(t, e) {
  if (!e) return t;
  if (e.includes("{url}")) return e.replace("{urlRaw}", g(t)).replace("{url}", encodeURIComponent(t));
  if (/[?&]url=?$/.test(e)) return `${e}${encodeURIComponent(t)}`;
  if (e.endsWith("?")) return `${e}url=${encodeURIComponent(t)}`;
  if (e.endsWith("/")) return `${e}${g(t)}`;
  let n = e.includes("?") ? "&" : "?";
  return `${e}${n}url=${encodeURIComponent(t)}`;
}
function T(t) {
  return new Promise((e, n) => {
    let o = new FileReader();
    o.onload = () => e(String(o.result || "")), o.onerror = () => n(new Error("read_failed")), o.readAsDataURL(t);
  });
}
function W(t, e) {
  return [e.as || "blob", e.timeout ?? 3e3, e.useProxy || "", e.errorTTL ?? 8e3, t].join("|");
}
async function E(t, e = {}) {
  let n = e.as ?? "blob", o = e.timeout ?? 3e3, r = e.useProxy || "", a = e.errorTTL ?? 8e3, l = e.headers || {}, f = !!e.silent;
  if (/^data:/i.test(t)) try {
    if (n === "text") return { ok: true, data: String(t), status: 200, url: t, fromCache: false };
    if (n === "dataURL") return { ok: true, data: String(t), status: 200, url: t, fromCache: false, mime: String(t).slice(5).split(";")[0] || "" };
    let [, i = "", c = ""] = String(t).match(/^data:([^,]*),(.*)$/) || [], p = /;base64/i.test(i) ? atob(c) : decodeURIComponent(c), w = new Uint8Array([...p].map((I) => I.charCodeAt(0))), U = new Blob([w], { type: (i || "").split(";")[0] || "" });
    return { ok: true, data: U, status: 200, url: t, fromCache: false, mime: U.type || "" };
  } catch {
    return { ok: false, data: null, status: 0, url: t, fromCache: false, reason: "special_url_error" };
  }
  if (/^blob:/i.test(t)) try {
    let i = await fetch(t);
    if (!i.ok) return { ok: false, data: null, status: i.status, url: t, fromCache: false, reason: "http_error" };
    let c = await i.blob(), u = c.type || i.headers.get("content-type") || "";
    return n === "dataURL" ? { ok: true, data: await T(c), status: i.status, url: t, fromCache: false, mime: u } : n === "text" ? { ok: true, data: await c.text(), status: i.status, url: t, fromCache: false, mime: u } : { ok: true, data: c, status: i.status, url: t, fromCache: false, mime: u };
  } catch {
    return { ok: false, data: null, status: 0, url: t, fromCache: false, reason: "network" };
  }
  if (/^about:blank$/i.test(t)) return n === "dataURL" ? { ok: true, data: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGMAAQAABQABDQottAAAAABJRU5ErkJggg==", status: 200, url: t, fromCache: false, mime: "image/png" } : { ok: true, data: n === "text" ? "" : new Blob([]), status: 200, url: t, fromCache: false };
  let d = W(t, { as: n, timeout: o, useProxy: r, errorTTL: a }), m = b.get(d);
  if (m && m.until > Date.now()) return { ...m.result, fromCache: true };
  m && b.delete(d);
  let S = k.get(d);
  if (S) return S;
  let h = P(t, r) ? j(t, r) : t, y = e.credentials;
  if (!y) try {
    let i = typeof location < "u" && location.href ? location.href : "http://localhost/", c = new URL(t, i);
    y = typeof location < "u" && c.origin === location.origin ? "include" : "omit";
  } catch {
    y = "omit";
  }
  let M = new AbortController(), O = setTimeout(() => M.abort("timeout"), o), $ = (async () => {
    try {
      let i = await fetch(h, { signal: M.signal, credentials: y, headers: l });
      if (!i.ok) {
        let p = { ok: false, data: null, status: i.status, url: h, fromCache: false, reason: "http_error" };
        if (a > 0 && b.set(d, { until: Date.now() + a, result: p }), !f) {
          let w = `${i.status} ${i.statusText || ""}`.trim();
          R.warnOnce(`http:${i.status}:${n}:${new URL(t, location?.href ?? "http://localhost/").origin}`, `HTTP error ${w} while fetching ${n} ${t}`);
        }
        return e.onError && e.onError(p), p;
      }
      if (n === "text") return { ok: true, data: await i.text(), status: i.status, url: h, fromCache: false };
      let c = await i.blob(), u = c.type || i.headers.get("content-type") || "";
      return n === "dataURL" ? { ok: true, data: await T(c), status: i.status, url: h, fromCache: false, mime: u } : { ok: true, data: c, status: i.status, url: h, fromCache: false, mime: u };
    } catch (i) {
      let c = i && typeof i == "object" && "name" in i && i.name === "AbortError" ? String(i.message || "").includes("timeout") ? "timeout" : "abort" : "network", u = { ok: false, data: null, status: 0, url: h, fromCache: false, reason: c };
      if (!/^blob:/i.test(t) && a > 0 && b.set(d, { until: Date.now() + a, result: u }), !f) {
        let p = `${c}:${n}:${new URL(t, location?.href ?? "http://localhost/").origin}`, w = c === "timeout" ? `Timeout after ${o}ms. Consider increasing timeout or using a proxy for ${t}` : c === "abort" ? `Request aborted while fetching ${n} ${t}` : `Network/CORS issue while fetching ${n} ${t}. A proxy may be required`;
        R.errorOnce(p, w);
      }
      return e.onError && e.onError(u), u;
    } finally {
      clearTimeout(O), k.delete(d);
    }
  })();
  return k.set(d, $), $;
}
async function G(t, e = {}) {
  if (/^((repeating-)?(linear|radial|conic)-gradient)\(/i.test(t) || t.trim() === "none") return t;
  let o = A(t);
  if (!o) return t;
  let r = g(o);
  if (s.background.has(r)) {
    let a = s.background.get(r);
    return a ? `url("${a}")` : "none";
  }
  try {
    let a = await E(r, { as: "dataURL", useProxy: e.useProxy });
    return a.ok ? (s.background.set(r, a.data), `url("${a.data}")`) : (s.background.set(r, null), "none");
  } catch {
    return s.background.set(r, null), "none";
  }
}
var L = /* @__PURE__ */ new Set(["meta", "script", "noscript", "title", "link", "template"]);
var C = /* @__PURE__ */ new Set(["meta", "link", "style", "title", "noscript", "script", "template", "g", "defs", "use", "marker", "mask", "clipPath", "pattern", "path", "polygon", "polyline", "line", "circle", "ellipse", "rect", "filter", "lineargradient", "radialgradient", "stop"]);
var v = ["div", "span", "p", "a", "img", "ul", "li", "button", "input", "select", "textarea", "label", "section", "article", "header", "footer", "nav", "main", "aside", "h1", "h2", "h3", "h4", "h5", "h6", "table", "thead", "tbody", "tr", "td", "th"];
function K() {
  for (let t of v) {
    let e = String(t).toLowerCase();
    L.has(e) || C.has(e) || x(e);
  }
}
function x(t) {
  if (t = String(t).toLowerCase(), C.has(t)) {
    let a = {};
    return s.defaultStyle.set(t, a), a;
  }
  if (s.defaultStyle.has(t)) return s.defaultStyle.get(t);
  let e = document.getElementById("snapdom-sandbox");
  e || (e = document.createElement("div"), e.id = "snapdom-sandbox", e.setAttribute("data-snapdom-sandbox", "true"), e.setAttribute("aria-hidden", "true"), e.style.position = "absolute", e.style.left = "-9999px", e.style.top = "-9999px", e.style.width = "0px", e.style.height = "0px", e.style.overflow = "hidden", document.body.appendChild(e));
  let n = document.createElement(t);
  n.style.all = "initial", e.appendChild(n);
  let o = getComputedStyle(n), r = {};
  for (let a of o) {
    if (_(a)) continue;
    let l = o.getPropertyValue(a);
    r[a] = l;
  }
  return e.removeChild(n), s.defaultStyle.set(t, r), r;
}
var Q = /(?:^|-)(animation|transition)(?:-|$)/i;
var q = /^(--|view-timeline|scroll-timeline|animation-trigger|offset-|position-try|app-region|interactivity|overlay|view-transition|-webkit-locale|-webkit-user-(?:drag|modify)|-webkit-tap-highlight-color|-webkit-text-security)$/i;
var V = /* @__PURE__ */ new Set(["cursor", "pointer-events", "touch-action", "user-select", "print-color-adjust", "speak", "reading-flow", "reading-order", "anchor-name", "anchor-scope", "container-name", "container-type", "timeline-scope"]);
function _(t) {
  let e = String(t).toLowerCase();
  return !!(V.has(e) || q.test(e) || Q.test(e));
}
function H(t, e) {
  if (e = String(e || "").toLowerCase(), C.has(e)) return "";
  let n = [], o = x(e);
  for (let [r, a] of Object.entries(t)) {
    if (_(r)) continue;
    let l = o[r];
    a && a !== l && n.push(`${r}:${a}`);
  }
  return n.sort(), n.join(";");
}
function X(t) {
  let e = /* @__PURE__ */ new Set();
  return t.nodeType !== Node.ELEMENT_NODE && t.nodeType !== Node.DOCUMENT_FRAGMENT_NODE ? [] : (t.tagName && e.add(t.tagName.toLowerCase()), typeof t.querySelectorAll == "function" && t.querySelectorAll("*").forEach((n) => e.add(n.tagName.toLowerCase())), Array.from(e));
}
function J(t) {
  let e = /* @__PURE__ */ new Map();
  for (let o of t) {
    let r = s.defaultStyle.get(o);
    if (!r) continue;
    let a = Object.entries(r).map(([l, f]) => `${l}:${f};`).sort().join("");
    a && (e.has(a) || e.set(a, []), e.get(a).push(o));
  }
  let n = "";
  for (let [o, r] of e.entries()) n += `${r.join(",")} { ${o} }
`;
  return n;
}
function z(t) {
  let e = Array.from(new Set(t.values())).filter(Boolean).sort(), n = /* @__PURE__ */ new Map(), o = 1;
  for (let r of e) n.set(r, `c${o++}`);
  return n;
}
function Y(t, e = null) {
  if (!(t instanceof Element)) return window.getComputedStyle(t, e);
  let n = s.computedStyle.get(t);
  if (n || (n = /* @__PURE__ */ new Map(), s.computedStyle.set(t, n)), !n.has(e)) {
    let o = window.getComputedStyle(t, e);
    n.set(e, o);
  }
  return n.get(e);
}
function Z(t) {
  let e = {};
  for (let n of t) e[n] = t.getPropertyValue(n);
  return e;
}
function tt(t) {
  let e = [], n = 0, o = 0;
  for (let r = 0; r < t.length; r++) {
    let a = t[r];
    a === "(" && n++, a === ")" && n--, a === "," && n === 0 && (e.push(t.slice(o, r).trim()), o = r + 1);
  }
  return e.push(t.slice(o).trim()), e;
}

export {
  s,
  et,
  A,
  B,
  g,
  E,
  G,
  L,
  C,
  K,
  H,
  X,
  J,
  z,
  Y,
  Z,
  tt
};
//# sourceMappingURL=chunk-NMVDEOIR.js.map
